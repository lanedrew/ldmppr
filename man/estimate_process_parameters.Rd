% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate_process_parameters.R
\name{estimate_process_parameters}
\alias{estimate_process_parameters}
\title{Estimate point process parameters using log-likelihood maximization}
\usage{
estimate_process_parameters(
  data,
  process = c("self_correcting"),
  grids,
  budgets,
  parameter_inits = NULL,
  delta = NULL,
  parallel = FALSE,
  num_cores = max(1L, parallel::detectCores() - 1L),
  set_future_plan = FALSE,
  strategy = c("local", "global_local", "multires_global_local"),
  global_algorithm = "NLOPT_GN_CRS2_LM",
  local_algorithm = "NLOPT_LN_BOBYQA",
  starts = list(global = 1L, local = 1L, jitter_sd = 0.35, seed = 1L),
  finite_bounds = NULL,
  refine_best_delta = TRUE,
  verbose = TRUE
)
}
\arguments{
\item{data}{A data.frame or matrix. Must contain either columns \code{(time, x, y)}
or \code{(x, y, size)}. If a matrix is provided without time, it must have
column names \code{c("x","y","size")}.}

\item{process}{Character string specifying the process model. Currently supports
\code{"self_correcting"}.}

\item{grids}{A \code{\link{ldmppr_grids}} object specifying the integration grid schedule
(single-level or multi-resolution). The integration bounds are taken from
\code{grids$upper_bounds}.}

\item{budgets}{A \code{\link{ldmppr_budgets}} object controlling optimizer options
for the global stage and local stages (first level vs refinement levels).}

\item{parameter_inits}{Optional numeric vector of length 8 giving initialization values
for the model parameters. If \code{NULL}, defaults are derived from \code{data} and
\code{grids$upper_bounds}.}

\item{delta}{Optional numeric scalar or vector. Used only when \code{data} does not contain
\code{time} (i.e., data has \code{(x,y,size)}).
\itemize{
  \item If \code{length(delta) == 1}, fits the model once using \code{power_law_mapping(size, delta)}.
  \item If \code{length(delta) > 1}, performs a delta-search by fitting the model for each candidate value
    and selecting the best objective. If \code{refine_best_delta = TRUE} and multiple grid levels are used,
    the best delta is refined on the remaining (finer) grid levels.
}
If \code{data} already contains \code{time}, \code{delta} is ignored when \code{length(delta)==1}
and is an error when \code{length(delta)>1}.}

\item{parallel}{Logical. If \code{TRUE}, uses furrr/future to parallelize either:
(a) over candidate \code{delta} values (when \code{length(delta) > 1}), and/or
(b) over local multi-start initializations (when \code{starts$local > 1}), and/or
(c) over global restarts (when \code{starts$global > 1}).}

\item{num_cores}{Integer number of workers to use when \code{set_future_plan = TRUE}.}

\item{set_future_plan}{If \code{TRUE}, temporarily sets
\code{future::plan(multisession, workers = num_cores)} and restores the original plan on exit.}

\item{strategy}{Character string specifying the estimation strategy:
\itemize{
  \item \code{"local"}: local optimization only (single-level or multi-level polish).
  \item \code{"global_local"}: global optimization then local polish (single grid level).
  \item \code{"multires_global_local"}: multi-resolution (coarsest uses global+local; refinements use local only).
}}

\item{global_algorithm, local_algorithm}{Character strings specifying the NLopt algorithms to use for
the global and local optimization stages, respectively.}

\item{starts}{A list controlling restart and jitter behavior:
\itemize{
  \item \code{global}: integer, number of global restarts at the first/coarsest level (default 1).
  \item \code{local}: integer, number of local multi-starts per level (default 1).
  \item \code{jitter_sd}: numeric SD for jittering (default 0.35).
  \item \code{seed}: integer base seed (default 1).
}}

\item{finite_bounds}{Optional list with components \code{lb} and \code{ub} giving finite lower and
upper bounds for all 8 parameters. If \code{NULL}, bounds are derived from \code{parameter_inits}.
Global algorithms in NLopt require finite bounds.}

\item{refine_best_delta}{Logical. If \code{TRUE} and \code{length(delta) > 1}, performs refinement
of the best \code{delta} across additional grid levels (if available).}

\item{verbose}{Logical. If \code{TRUE}, prints progress messages during fitting.}
}
\value{
An object of class \code{"ldmppr_fit"} containing the best \code{nloptr} fit and
  (optionally) stored fits from global restarts and/or a delta search.
}
\description{
Estimate spatio-temporal point process parameters by maximizing the (approximate)
full log-likelihood using \code{\link[nloptr:nloptr]{nloptr}}.
}
\details{
For the self-correcting process, arrival times must lie on \eqn{(0,1)} and can be
supplied directly in \code{data} as \code{time}, or constructed from \code{size}
via the gentle-decay (power-law) mapping \code{\link{power_law_mapping}} using
\code{delta}. When \code{delta} is a vector, the model is fit for each candidate
value and the best objective is selected.

This function supports multi-resolution estimation via a \code{\link{ldmppr_grids}}
schedule. If multiple grid levels are provided, the coarsest level may use a global
optimizer followed by local refinement, and subsequent levels run local refinement only.
}
\examples{
data(small_example_data)

ub <- c(1, 25, 25)
g  <- ldmppr_grids(upper_bounds = ub, levels = list(c(10,10,10)))
b  <- ldmppr_budgets(
  global_options = list(maxeval = 150),
  local_budget_first_level = list(maxeval = 50, xtol_rel = 1e-2),
  local_budget_refinement_levels = list(maxeval = 25, xtol_rel = 1e-2)
)

fit <- estimate_process_parameters(
  data = small_example_data,
  grids = g,
  budgets = b,
  delta = 1,
  strategy = "global_local",
  global_algorithm = "NLOPT_GN_CRS2_LM",
  local_algorithm  = "NLOPT_LN_BOBYQA",
  starts = list(global = 2, local = 2, jitter_sd = 0.25, seed = 1),
  verbose = TRUE
)
coef(fit)
logLik(fit)

\donttest{
g2 <- ldmppr_grids(upper_bounds = ub, levels = list(c(8,8,8), c(12,12,12)))
fit_delta <- estimate_process_parameters(
  data = small_example_data, # x,y,size
  grids = g2,
  budgets = b,
  delta = c(0.35, 0.5, 0.65, 0.9, 1.0),
  parallel = TRUE,
  set_future_plan = TRUE,
  num_cores = 2,
  strategy = "multires_global_local",
  starts = list(local = 1),
  refine_best_delta = FALSE,
  verbose = FALSE
)
plot(fit_delta)
}

}
\references{
MÃ¸ller, J., Ghorbani, M., & Rubak, E. (2016). Mechanistic spatio-temporal point process models
for marked point processes, with a view to forest stand data. \emph{Biometrics}, 72(3), 687-696.
\doi{10.1111/biom.12466}.
}
